//prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User model for authentication
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // bcrypt hashed
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  settings   UserSettings?
  gardens    Garden[]
  beds       Bed[]
  plants     Plant[]

  // NextAuth.js session support
  accounts           Account[]
  sessions           Session[]
  passwordResetTokens PasswordResetToken[]

  @@index([email])
}

// NextAuth.js models (required by PrismaAdapter)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Password reset tokens
model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique // hashed token
  expires   DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
}

// User settings - now per-user instead of singleton
model UserSettings {
  id        Int      @id @default(autoincrement())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lastSpringFrost DateTime
  firstFallFrost  DateTime
  zone            String?
  units           String   @default("imperial") // "imperial" or "metric"

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Plant model - now per-user
model Plant {
  id        Int      @id @default(autoincrement())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name          String
  variety       String?
  spacingInches Int     @default(12)

  daysToMaturityMin Int?
  daysToMaturityMax Int?

  startIndoorsWeeksBeforeFrost  Int?
  transplantWeeksAfterFrost     Int?
  directSowWeeksRelativeToFrost Int?

  plantingDepthInches Float?

  notes String?

  placements BedPlacement[]
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, name])
}

// Bed model - now per-user
model Bed {
  id        Int      @id @default(autoincrement())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name         String
  widthInches  Int
  heightInches Int
  cellInches   Int     @default(12) // grid size: 6 or 12 are common
  gardenX      Int? // top-left position in garden grid cells
  gardenY      Int? // top-left position in garden grid cells
  gardenRotated Boolean @default(false)

  placements BedPlacement[]
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Garden model - now per-user, removed hardcoded id=1
model Garden {
  id           Int      @id @default(autoincrement())
  userId       String   @unique // one garden per user
  widthInches  Int
  heightInches Int
  cellInches   Int      @default(12)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// BedPlacement - no changes needed (inherits through Bed relationship)
model BedPlacement {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bedId   Int
  plantId Int

  // Grid coordinates (0-based)
  x Int
  y Int
  w Int @default(1) // width in cells
  h Int @default(1) // height in cells

  count Int @default(1)

  bed   Bed   @relation(fields: [bedId], references: [id], onDelete: Cascade)
  plant Plant @relation(fields: [plantId], references: [id], onDelete: Cascade)

  @@unique([bedId, x, y]) // prevents two placements from sharing the exact same cell
}
